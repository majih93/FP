# 5장

핵심 내용

- 압묵적 입출력을 제거해서 재사용하기 좋은 코드를 만들어본다.
- 복잡하게 엉킨 코드를 풀어 더 좋은 구조로 만드는 방법을 배운다.

## 비즈니스 요구사항과 설계를 맞추기.

`gets_free_shipping()` 함수의 비즈니스 요구사항은, 장바구니에 담긴 제품을 주문할 때 무료 배송인지 확인하는 것이다.

하지만 현재의 구현은 비즈니스 요구사항에 맞지 않는 부분이 있다.

```javascript
// '장바구니'로 무료 배송을 확인하는 것이 아니라, 제품의 합계와 가격으로 확인하고 있음.
function get_free_shipping(total, item_price) {
  return total + item_price >= 20;
}

// 위 함수를 cart를 받는 함수로 변경해보자.
// 그리고 계산 로직은 이미 존재하는 함수 calc_total로 대체하여 중복을 줄인다.
function get_free_shipping(cart) {
  return calc_total(cart) >= 20;
}
```

한 가지 바로 이해되지 않는 설명은, 기존 총액과 새로운 제품의 가격을 받는 것 대신 cart를 전달하는 것이 비즈니스 로직에 더 맞는 변경사항이라는 것의 근거 중 하나가 `장바구니는 정자상거래에서 많이 사용하는 엔터티 타입이기 때문이다`라는 점.

- `엔터티`: 업무에 필요하고 유용한 정보를 저장하고 관리하기 위한 집합적인 것.
- 장바구니라는 엔터티가, 통상적으로 사람들이 '장바구니란 ~한 기능을 하는 데이터의 집합이다` 라는 것에 대한 상호이해가 있기 때문에 좋다 라는 것일까?
  - 장바구니에 대해서 사람들이 기대하는 기능 및 처리가 어느정도 동일할 것이기 때문에 그렇다는것인가

## 원칙

> 암묵적 입력과 출력은 적을수록 좋다.

암묵적 입력과 출력이 있다는 것은 다른 컴포넌트와 강하게 결합이 되어 있다는 의미.

그리고 다른 곳에서 사용할 수 없기 때문에, `모듈`이라고 볼 수 없음.

조심해서 사용해야 하며(아무 때나 실행할 수 없음.), 테스트하기도 어렵다.

## 계산 분류하기

의미가 있는 계층을 알아보기 위해서 계산을 분류했다고 했는데

`의미가 있는 계층`이라는 것이 뭘까?

지금 단계에서는 이렇게 이해된다. 여러 코드 조각(모음)이 있을 때, 이를 유의미하게 분류할 수 있는 기준이 되는 그 무언가 아닐까?

그러면 이렇게 유의미하게 분리해야되는 이유가 뭘까?
-> 8, 9장에서 관련된 내용을 다룬다고 한다.

내 생각에는 일단 코드를 중구난방으로 쓰기 보다는, `이 코드는 이런 것과 연관이 있다` 이런 맥락에서 도움이 되지 않을까 싶다.

그래서 관련 있는 코드끼리는 모아두거나 할 수 있기도 하고, 관련 있는 코드들끼리 또 최적화를 할 수도 있지 않을까?

또한 분류가 애매하다 -> 개선할 여지가 있는 코드이다 라고도 해석할 수 있을 것 같다.

주관적인 영역이라 어렵지만, 상황에 따라 적용해볼만한 기준이라고 보면 될 것 같음.

---

이어서 읽기 위해서 가볍게 복습하고 넘어가려고 하는 중에, `의미있는 계층`에 대해서 조금 더 생각해봤다.

함수를

- cart에 대한 동작
- item에 대한 동작
- 비즈니스 규칙

이렇게 3가지로 분류했는데, `의미있는 계층`이라는 단어에 집착하기 보다는 엉켜있는 코드가 의도와 category가 명확한 코드 조각들로 나뉘어졌다는 것 자체가 중요한 점이라는 생각이 든다.

category가 명확한 코드로 변경하는 것이 어떤 의미가 있을까?

요즘 같이 일하는 사람들이 내가 작성한 코드를 이해하고 수정하는데 소요되는 cognitive load를 줄이는 것에 대해서 이런 저런 고민들이 생기는데, 이와 연관해서 category를 기준으로 코드를 분류하는 것이 다음과 같은 장점이 있지 않을까 하는 생각이 들었다.

- 소통 load를 줄이는 일관된 컨텍스트가 존재한다. (JavaScript를 사용하는 문법에 대해서는 서로 같은 이해를 가지고 있는 것처럼, 이 코드는 이것에 연관된 것이구나, 이 코드는 저것과 연관된 것이구나 등등)
- 이해의 범위를 한정짓는다. 특정 기능을 수정해야된다고 했을 때, 봐야하는 코드의 범위가 정해져있다.
- 다음 사람도 해당 분류를 기준으로 코드를 작성할 수 있다. 코드가 늘어나더라도 복잡도가 올라갈 위험이 조금 줄어든다.
- 분류를 지어서 코드를 작성하는 행위 자체가 팀의 코드 스타일이 될 수 있다. 분류에 해당되지 않는 코드가 존재할 때, 적절한 새로운 카테고리를 고민하고 작성할 수 있다.
- 카테고리가 애매한 코드가 있다면, 분리해야된다는 신호로 이해할 수 있다.
- input에 대해서 의도한 output이 출력되는지 테스트하기 용이하다.

## 원칙: 설계는 엉켜있는 코드를 푸는 것이다.

> 함수는 인자로 넘기는 값과 그 값을 사용하는 방법을 분리한다.

엉켜있는 실타래를, 개별적인 실로 분리하는 것과 비슷하게 생각할 수 있다.

잘 분리된 작은 함수의 장점이 뭘까?

**재사용하기 쉽다**

작을수록 재사용하기 쉬움. 사용할 때 cognitive load가 크지 않지 않을까.

**유지보수하기 쉽다**

쉽게 이해할 수 있고, 잘못된 부분을 직관적으로 이해할 수 있음.

**테스트하기 쉽다**

작은 일은 이상적으로는 한 가지 일만 하기 때문에, 그 한 가지 일만 테스트하면 된다.

## 원칙을 기준으로 코드를 분리해보기

책의 이 부분에서는 앞서 계층을 분리한 구조를 실제 코드에 적용한다.

### `add_item`을 분리해서 더 좋은 설계 만들기

아래의 `add_item`함수는 cart와 item의 구조를 모두 알고 있음.

```javascript
// cart는 item으로 구성된 배열
function add_item(cart, name, price) {
  var new_cart = cart.slice(); // 1. cart배열 복사
  new_cart.push({
    // 2. item객체 생성해서 복사한 배열에 push
    name: name,
    price: price,
  });
  return new_cart; // 3. 필요한 작업이 반영된 복사본 반환
}
```

여기서 item에 관한 코드를 별도 함수로 분리해보자.

책을 보기 전에 내 나름대로 생각을 해서 분리해보았다.

**내가 수정해본 코드**

item에 관한 코드가 뭘까?

item객체를 생성하는 부분이다.

그렇다면 이것을 분리하지 않았을 때 생기는 문제점이 뭐가 있을까?

지금까지 공부한 내용을 토대로 생각해봤을 때, 다음과 같은 문제점들이 있다.

- item의 구조가 변경되면 이 함수 안의 내용도 변경해야 한다.(변경하지 않으면 버그가 발생한다.) 같은 로직에 대해서 다른 버전의 코드가 존재할 수 있는 위험성이 있음.
- cart에 push되는 것이 item이라는 점이 일견 명확하지 않다. 처음 코드를 보는 사람이라면 뭘 push하는 것인지 직관적이지 않을 수 있음.
- cart의 자료구조 형식이 변경되면, 이에 따라서 코드를 수정해야됨.

내가 생각한 방식은 다음과 같다.

- name과 price가 주어졌을 때, item을 반환하는 함수를 만든다.
- add_item 안에서 해당 함수를 호출해서 생성된 결과값을 new_cart에 추가한다.

```javascript
// 새로운 item생성함수
function create_item(name, price) {
  return {
    name: name,
    price: price
  }
}

// add_item코드를 create_item을 사용해서 수정
function add_item(cart, name, price) {
  var new_cart = cart.slice(); // 1. cart배열 복사
  const item = create_item(name, price) // 2. create_item함수를 활용해서 새로운 아이템 생성
  new_cart.push(item); // 3. 복사본에 추가
  return new_cart; // 4. 복사본 반환
}

// 코드를 쓰다보니, 왜 Swift는 data를 미리 struct등으로 구조화해서 init해서 쓰는지 좀 이해가 된다. 만약에 JavaScript도 이게 가능하겠지만, 뭔가 덜 natural하게 느껴진다고 해야하나?
// swift였다면 이런 느낌이었을것 같음.
// TypeScript가 이런 부분을 보완해준다.
struct Item {
  var name: String
  var price: Double
}

var item: Item = Item(name: '', price: 1.0)
```

**책에서 제시한 개선방법**

`item`을 생성하는 함수를 분리하는 것 까지는 아이디어는 동일했다.

하지만 내가 다르게 생각한 부분은 add_item 함수의 개선된 구조임.

나는 add_item안에서 item을 생성하는 형태로 작성하였는데, 책에서 제시한 개선안은 item을 생성하는 로직 자체를 아예 add_item 밖으로 분리하였음.

이러면 add_item은 item이 어떻게 형성되는지, 어떤 구조인지 이런 부분에 대해서 아무것도 알 필요가 없음. 그냥 item을 받아서, 복사한 배열에 넣어서 복사한 배열을 반환하기만 하면 된다.

```javascript
function add_item(cart, item) {
  var new_cart = cart.slice(); // 1. cart배열 복사
  new_cart.push(item); // 2. 복사본에 추가
  return new_cart; // 3. 복사본 반환
}

// 생성하는 함수 이름도 조금 더 명확한 것 같음
function make_cart_item(name, price) {
  //.. 생성
}

// item을 생성하는 것은 전달하는 시점에
add_item(shopping_cart, make_cart_item("shoes", 3.45));
```

add_item은 이제 cart의 구조에 대해서만 신경쓰면 된다.

그리고 make_cart_item은 item의 구조만 신경쓰면 됨.

### 카피-온-라이트 패턴 빼내기(일반화하기)

여기서 `add_item`함수가 하는 일을 추상화해보자.

하는 역할은 일반화하면 다음과 같다.

- 배열과 추가할 요소를 입력받아서,
- 배열을 복사하고,
- 복사한 배열의 마지막에 새로운 요소를 추가하고,
- 처리된 복사배열을 반환한다.

하는 일만 보면, 이게 꼭 `cart`에 어떤 `item`을 추가하는 구체적인 일에 대한 것이 아님을 알 수 있다.

이는 `cart`와 같은 `array`에 어떤 `item`과 같은 `element`를 추가하는 일이다.

비단 `cart`뿐만 아니라, 배열에 요소를 추가하는 작업이 필요한 어떤 함수에서도 활용될 수 있고 충분히 여러번 반복될 가능성이 있는 코드이다.

그래서 이를 빼내서 일반화하고, 이 일반화된 형태의 함수를 활용해서 구체적인 기능을 구현하는 구조로 코드를 변경한다.

```javascript
// 일반화된 함수
// 이는 재사용가능한 utility함수이다.
function add_element_last(array, item) {
  var new_array = array.slice();
  new_array.push(item);
  return new_array;
}

// 일반화된 함수를 활용해서 구체적인 케이스를 구현
function add_cart_item(cart, item) {
  return add_element_last(cart, item);
}
```

결론적으로, 하나의 함수였던 `add_item`이 세 개의 함수로 쪼개짐.
